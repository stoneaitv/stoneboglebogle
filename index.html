<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Retro Bubble Platformer</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; margin: 0; }
    body { display:flex; flex-direction:column; background:#0b0c10; color:#eaeaea; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, sans-serif; }
    header { padding:.6rem 1rem; display:flex; gap:1rem; align-items:center; justify-content:space-between; border-bottom:1px solid #222; background:#111317; position:sticky; top:0; z-index:10; }
    .brand { font-weight:800; letter-spacing:.2px; }
    .btn { appearance:none; border:0; background:#2b6cb0; color:#fff; padding:.5rem .8rem; border-radius:.6rem; font-weight:700; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .hud { display:flex; gap:1rem; align-items:center; }

    #wrap { display:grid; grid-template-columns:1fr; place-items:center; padding:10px; }
    canvas { width:min(100vw, 900px); height: calc(min(100vw, 900px) * 0.5625); max-height: 85vh; image-rendering: pixelated; background:#0a0a0a; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06); }

    /* 모바일 터치 패드 */
    #touchpad { position:fixed; inset:auto 0 0 0; display:flex; justify-content:space-between; gap:10px; padding:10px; pointer-events:auto; }
    .pad { display:grid; place-items:center; background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:10px; }
    .dpad { grid-template-columns:repeat(3,56px); grid-template-rows:repeat(3,56px); gap:6px; }
    .dpad button { width:56px; height:56px; border-radius:14px; background:#1f2937; border:1px solid #374151; color:#e5e7eb; font-weight:800; font-size:18px; }
    .ab { display:grid; grid-template-columns:repeat(2,80px); gap:10px; align-content:center; }
    .ab button { width:80px; height:80px; border-radius:50%; background:#374151; border:1px solid #4b5563; color:#fff; font-weight:900; font-size:18px; }

    @media (min-width: 900px){ #touchpad { display:none; } }
  </style>
</head>
<body>
  <header>
    <div class="brand">Retro Bubble Platformer</div>
    <div class="hud">
      <div>스테이지: <span id="stage">1</span></div>
      <div>점수: <span id="score">0</span></div>
      <button class="btn" id="restart">다시시작</button>
    </div>
  </header>
  <div id="wrap">
    <!-- 내부 논리 해상도 800x450 (16:9) 고정, CSS로 스케일링 -->
    <canvas id="game" width="800" height="450" aria-label="bubble platformer canvas" role="img"></canvas>
  </div>

  <!-- 모바일 조작 패드 -->
  <div id="touchpad" aria-hidden="false">
    <div class="pad dpad">
      <button data-k="ArrowUp">▲</button>
      <button disabled></button>
      <button data-k="Space">●</button>
      <button data-k="ArrowLeft">◀</button>
      <button disabled></button>
      <button data-k="ArrowRight">▶</button>
      <button disabled></button>
      <button data-k="KeyZ">A</button>
      <button data-k="KeyX">B</button>
    </div>
    <div class="pad ab">
      <button data-k="KeyZ">점프(A)</button>
      <button data-k="KeyX">버블(B)</button>
      <button data-k="Space" style="grid-column: span 2">버블(스페이스)</button>
    </div>
  </div>

  <script>
    // === 간단 보글보글 스타일의 오마주 게임 ===
    // - 저작권 문제 회피를 위해 모든 자산은 벡터/코드로 생성, 이름/그래픽 독자 구현
    // - PC: ← → (이동), Z(점프), X/Space(버블)
    // - 모바일: 하단 터치패드

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = canvas.width, H = canvas.height;
    const G = 0.5;             // 중력
    const FRICTION = 0.86;     // 지면 감쇠
    const MAX_VX = 4.2;
    const JUMP_VY = -10.5;

    const ui = {
      score: document.getElementById('score'),
      stage: document.getElementById('stage'),
      restart: document.getElementById('restart')
    };

    // 입력
    const keys = new Set();
    const press = k => keys.add(k);
    const release = k => keys.delete(k);

    addEventListener('keydown', e => { if(['ArrowLeft','ArrowRight','ArrowUp','Space','KeyZ','KeyX'].includes(e.code)) { e.preventDefault(); press(e.code);} });
    addEventListener('keyup',   e => { if(['ArrowLeft','ArrowRight','ArrowUp','Space','KeyZ','KeyX'].includes(e.code)) { e.preventDefault(); release(e.code);} });

    // 모바일 터치패드 → 키 이벤트 흉내
    document.querySelectorAll('#touchpad [data-k]').forEach(btn =>{
      const code = btn.dataset.k;
      const on = (ev)=>{ ev.preventDefault(); press(code); };
      const off= (ev)=>{ ev.preventDefault(); release(code); };
      btn.addEventListener('touchstart', on, {passive:false});
      btn.addEventListener('touchend',   off, {passive:false});
      btn.addEventListener('touchcancel',off, {passive:false});
      btn.addEventListener('mousedown', on);
      btn.addEventListener('mouseup', off);
      btn.addEventListener('mouseleave', off);
    });

    // 타일 맵 (간단 스테이지들)
    // 0 빈공간, 1 벽, 2 스프링(점프), 3 가시(피해)
    const stages = [
      [
        '11111111111111111111',
        '1..................1',
        '1..................1',
        '1......1111........1',
        '1..................1',
        '1..1111......111...1',
        '1..................1',
        '1......1111........1',
        '1..................1',
        '1..2.............3.1',
        '1..................1',
        '1..................1',
        '1..................1',
        '1..................1',
        '1..................1',
        '1...........11.....1',
        '1..................1',
        '1..........1111....1',
        '1..................1',
        '11111111111111111111',
      ],
      [
        '11111111111111111111',
        '1..................1',
        '1......1111........1',
        '1.............111..1',
        '1..................1',
        '1..1111............1',
        '1.............111..1',
        '1..................1',
        '1.....1111.........1',
        '1...............3..1',
        '1..................1',
        '1.....1111.........1',
        '1..................1',
        '1.........1111.....1',
        '1..................1',
        '1..2...............1',
        '1..................1',
        '1..........1111....1',
        '1..................1',
        '11111111111111111111',
      ],
    ];

    const tileSize = 40; // 20x20 타일 → 800x800, 실제 높이 450이므로 y는 일부만 보임

    function tileAt(x,y){
      const tx = Math.floor(x/tileSize);
      const ty = Math.floor(y/tileSize);
      const row = stages[game.stageIndex][ty];
      if(!row) return 1; // 바깥은 벽
      const ch = row[tx];
      return ch === '1' ? 1 : ch === '2' ? 2 : ch === '3' ? 3 : 0;
    }

    // 엔티티
    function makePlayer(){
      return { x: 80, y: H-80, w: 28, h: 28, vx:0, vy:0, onGround:false, dir:1, alive:true, inv:0 };
    }
    function makeEnemy(x,y){
      return { x, y, w:26, h:26, vx: (Math.random()<.5?-1:1)*1.2, vy:0, alive:true, bubbled:false, bubbleT:0 };
    }
    function makeBubble(x,y,dir){
      return { x, y, r:9, vx: dir*4.2, vy:-2.5, life: 180 };
    }

    const game = {
      stageIndex: 0,
      score: 0,
      player: makePlayer(),
      enemies: [],
      bubbles: [],
      particles: [],
      spawnStage(){
        this.enemies = [
          makeEnemy(520, 120),
          makeEnemy(700, 100),
          makeEnemy(260, 80)
        ];
        this.bubbles = [];
      }
    };

    function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    // 충돌 처리(타일)
    function collideWithTiles(e){
      // 수평
      e.x += e.vx;
      if(e.vx>0){ // 오른쪽
        const right = e.x + e.w;
        if(tileAt(right, e.y)===1 || tileAt(right, e.y+e.h-1)===1){
          e.x = Math.floor((right)/tileSize)*tileSize - e.w - 0.01;
          e.vx = 0;
        }
      } else if(e.vx<0){
        const left = e.x;
        if(tileAt(left, e.y)===1 || tileAt(left, e.y+e.h-1)===1){
          e.x = Math.floor((left)/tileSize+1)*tileSize + 0.01;
          e.vx = 0;
        }
      }
      // 수직
      e.vy += G;
      e.y += e.vy;
      e.onGround = false;
      if(e.vy>0){ // 아래로
        const bottom = e.y + e.h;
        if(tileAt(e.x+2, bottom)===1 || tileAt(e.x+e.w-2, bottom)===1){
          e.y = Math.floor(bottom/tileSize)*tileSize - e.h - 0.01;
          e.vy = 0; e.onGround = true; e.vx *= FRICTION;
        }
      } else if(e.vy<0){ // 위로
        const top = e.y;
        if(tileAt(e.x+2, top)===1 || tileAt(e.x+e.w-2, top)===1){
          e.y = Math.floor(top/tileSize+1)*tileSize + 0.01;
          e.vy = 0;
        }
      }

      // 스프링/가시 처리
      const under = tileAt(e.x + e.w/2, e.y + e.h + 1);
      if(under === 2 && e.onGround){ e.vy = JUMP_VY * 1.2; e.onGround = false; }
      const here  = tileAt(e.x + e.w/2, e.y + e.h/2);
      if(here === 3 && e === game.player && e.inv<=0){ // 가시 닿으면 페널티
        e.inv = 120; game.score = Math.max(0, game.score - 200);
        particles(e.x+e.w/2, e.y+e.h/2, 12, '#ff4d4d');
      }
    }

    // 파티클
    function particles(x,y,n,color){
      for(let i=0;i<n;i++){
        game.particles.push({x,y, vx:(Math.random()*2-1)*3, vy:(Math.random()*2-1)*3, life: 30+Math.random()*20, color});
      }
    }

    function update(){
      const p = game.player;
      if(!p.alive) return;

      // 입력 처리
      const left = keys.has('ArrowLeft');
      const right = keys.has('ArrowRight');
      const jump = keys.has('KeyZ') || keys.has('ArrowUp');
      const shoot = keys.has('KeyX') || keys.has('Space');

      if(left) { p.vx = Math.max(p.vx-0.6, -MAX_VX); p.dir=-1; }
      if(right){ p.vx = Math.min(p.vx+0.6,  MAX_VX); p.dir= 1; }
      if(!left && !right && p.onGround){ p.vx *= FRICTION; if(Math.abs(p.vx)<0.05) p.vx=0; }
      if(jump && p.onGround){ p.vy = JUMP_VY; p.onGround = false; }

      // 버블 쿨다운 간단 처리
      p.shootCd = Math.max(0, (p.shootCd||0)-1);
      if(shoot && p.shootCd===0){ p.shootCd = 14; game.bubbles.push(makeBubble(p.x + p.w/2, p.y + p.h/2, p.dir)); }

      collideWithTiles(p);
      if(p.inv>0) p.inv--;

      // 적 갱신
      for(const e of game.enemies){
        if(!e.alive) continue;
        if(e.bubbled){
          e.bubbleT++;
          e.y += Math.sin(e.bubbleT/10)*0.5 - 0.4; // 둥둥 떠오름
          if(e.bubbleT>600){ e.bubbled=false; e.vx = (Math.random()<.5?-1:1)*1.2; e.vy=0; } // 오래 놔두면 탈출
        } else {
          // 벽에서 튕기기
          e.vy += G*0.8;
          e.x += e.vx; e.y += e.vy;
          // 간단한 벽 체크
          if(tileAt(e.x, e.y)===1 || tileAt(e.x, e.y+e.h-1)===1){ e.x += 1.8; e.vx *= -1; }
          if(tileAt(e.x+e.w, e.y)===1 || tileAt(e.x+e.w, e.y+e.h-1)===1){ e.x -= 1.8; e.vx *= -1; }
          if(tileAt(e.x+2, e.y+e.h)===1 || tileAt(e.x+e.w-2, e.y+e.h)===1){ e.y = Math.floor((e.y+e.h)/tileSize)*tileSize - e.h - 0.01; e.vy=0; }
          // 플레이어 충돌
          if(rectsOverlap(p,e) && p.inv<=0){ p.inv=90; particles(p.x+p.w/2, p.y+p.h/2, 10,'#ffd166'); game.score = Math.max(0, game.score-100); }
        }
      }

      // 버블 갱신 & 적 포획
      for(const b of game.bubbles){
        b.life--; b.x += b.vx; b.y += b.vy; b.vy += -0.02; // 점점 천천히 올라감
        // 벽 반사
        if(tileAt(b.x+b.r, b.y)===1 || tileAt(b.x-b.r, b.y)===1) b.vx *= -1;
        if(tileAt(b.x, b.y-b.r)===1) b.vy = Math.abs(b.vy);
        // 적과 충돌 → 포획
        for(const e of game.enemies){
          if(!e.alive || e.bubbled) continue;
          if(Math.hypot((e.x+e.w/2)-b.x, (e.y+e.h/2)-b.y) < b.r + Math.min(e.w,e.h)/2){
            e.bubbled = true; e.vx=0; e.vy=0; particles(b.x,b.y,8,'#66e3ff'); b.life=0; game.score+=150;
          }
        }
      }
      // 버블 제거
      game.bubbles = game.bubbles.filter(b => b.life>0 && b.y > -30);

      // 버블 터뜨리기(플레이어가 닿으면 점수&적 제거)
      for(const e of game.enemies){
        if(e.bubbled && rectsOverlap({x:e.x,y:e.y,w:e.w,h:e.h}, p)){
          e.alive=false; e.bubbled=false; particles(e.x+e.w/2, e.y+e.h/2, 20,'#8aff8a'); game.score+=300;
        }
      }

      // 스테이지 클리어
      if(game.enemies.every(e=>!e.alive)){
        game.stageIndex = (game.stageIndex+1) % stages.length;
        ui.stage.textContent = (game.stageIndex+1);
        game.spawnStage();
        particles(p.x,p.y,40,'#a78bfa');
      }

      ui.score.textContent = game.score;
    }

    function draw(){
      // 배경(그라디언트)
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#0f172a'); g.addColorStop(1,'#111827');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      // 타일 렌더
      const map = stages[game.stageIndex];
      for(let y=0;y<map.length;y++){
        for(let x=0;x<map[y].length;x++){
          const ch = map[y][x];
          const px = x*tileSize, py = y*tileSize;
          if(ch==='1'){
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(px,py,tileSize,tileSize);
            ctx.strokeStyle='rgba(255,255,255,.05)'; ctx.strokeRect(px+0.5,py+0.5,tileSize-1,tileSize-1);
          } else if(ch==='2'){
            ctx.fillStyle = '#10b981';
            ctx.fillRect(px,py,tileSize,tileSize);
          } else if(ch==='3'){
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.moveTo(px+4, py+tileSize-4); ctx.lineTo(px+tileSize/2, py+4); ctx.lineTo(px+tileSize-4, py+tileSize-4); ctx.closePath(); ctx.fill();
          }
        }
      }

      // 버블
      for(const b of game.bubbles){
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(102, 227, 255, .35)'; ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,.7)'; ctx.lineWidth = 2; ctx.stroke();
        ctx.lineWidth = 1;
      }

      // 적
      for(const e of game.enemies){
        if(!e.alive) continue;
        if(e.bubbled){
          ctx.fillStyle = 'rgba(166, 227, 161, .25)';
          ctx.beginPath(); ctx.ellipse(e.x+e.w/2, e.y+e.h/2, 18, 22, 0, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,.7)'; ctx.stroke();
          // 안의 적 실루엣
          ctx.fillStyle = '#94a3b8'; ctx.fillRect(e.x+6, e.y+8, e.w-12, e.h-12);
        } else {
          ctx.fillStyle = '#fcd34d'; ctx.fillRect(e.x, e.y, e.w, e.h);
          ctx.fillStyle = '#0f172a'; ctx.fillRect(e.x+6, e.y+6, 4,4); ctx.fillRect(e.x+e.w-10, e.y+6, 4,4);
        }
      }

      // 플레이어
      const p = game.player;
      if(p.inv>0 && (p.inv%6<3)) ctx.globalAlpha = 0.4; else ctx.globalAlpha = 1;
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      // 눈/입
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(p.x+6, p.y+6, 5,5);
      ctx.fillRect(p.x+p.w-11, p.y+6, 5,5);
      ctx.fillRect(p.x+9, p.y+p.h-10, 10,3);
      ctx.globalAlpha = 1;

      // 파티클
      for(const pt of game.particles){
        pt.life--; pt.x += pt.vx; pt.y += pt.vy; ctx.globalAlpha = Math.max(0, pt.life/40);
        ctx.fillStyle = pt.color; ctx.fillRect(pt.x, pt.y, 3,3);
      }
      game.particles = game.particles.filter(p=>p.life>0);

      // HUD 안내
      ctx.globalAlpha = .85; ctx.fillStyle = '#e5e7eb'; ctx.font='14px ui-sans-serif, system-ui';
      ctx.fillText('이동: ← →   점프: Z/↑   버블: X/Space   (모바일: 하단 패드)', 14, 24);
      ctx.globalAlpha = 1;
    }

    function loop(){ update(); draw(); requestAnimationFrame(loop); }

    function reset(){
      game.player = makePlayer();
      game.score = 0; game.stageIndex = 0; ui.stage.textContent = 1; ui.score.textContent = 0;
      game.spawnStage();
    }

    ui.restart.addEventListener('click', reset);

    // 초기화
    reset();
    loop();
  </script>

  <!-- 사용법
    1) 이 파일을 index.html 로 저장 → 더블클릭 또는 로컬 서버에서 열면 바로 플레이
    2) GitHub Pages 배포: 이 파일을 리포지토리 루트에 올리면 끝
    3) 커스텀: stages 배열로 맵 수정, 색상/속도/점수 조정 가능
  -->
</body>
</html>